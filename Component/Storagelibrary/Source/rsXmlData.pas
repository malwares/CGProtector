{*******************************************************}
{                                                       }
{                Delphi VCL Extensions                  }
{                   Storage library                     }
{                                                       }
{         Copyright (c) 2000-2007 Deepsoftware          }
{                                                       }
{           www - http://www.deepsoftware.com           }
{              email - ray@deepsoftware.com             }
{                                                       }
{*******************************************************}
unit rsXmlData;

interface

{$I rsStorage.inc}

uses {$IFDEF RSL_WIN}Windows,{$ENDIF} Classes, SysUtils, rsStorage, rsConst;

const
  CXMLkoAttribute = $0001;
  CXMLkoValueInAttribute = $0002;
  CXMLkoValueInData = $0004;


//errors
  SErrXMLEOF = 'Unexpected end of file.';
  SErrMissingEQ = 'Missing equality sign.';
  SErrMissingQuote = 'Missing quotation mark.';
  SErrMissingEndTag = 'Missing end tag mark.';
  SErrMissingBeginTag = 'Missing begin tag mark.';
  SErrMissingStr = 'Missing %s mark.';
  SErrUnknownEntity = 'Unknown entity.';
  SErrInEntity = 'No end mark in the entity.';

type
  TrsXMLTokenEndChars = set of Char;

  TrsXMLDataOption = (doKeyValueInAttribute, doGetTemplateOnLoad, doEncodeTab, doEncodeCRLF);
  TrsXMLDataOptions = set of TrsXMLDataOption;

  TrsXMLCompactOption = (coHexStr, coIndent, coEOL);
  TrsXMLCompactOptions = set of TrsXMLCompactOption;


  TrsXMLData = class(TrsStreamData)
  private
    FAttrNames: TStringList;
    FAttrValues: TStringList;

    PBufStart: PAnsiChar;
    PCur: PAnsiChar;

    FCurrentIndention: integer;
    FCurrentRootName: WideString; //string;
    FCurrentSectionName: RSLString;
    FTemplate: TStrings;
    FRootName: string;
    FXMLDataOptions: TrsXMLDataOptions;

    FTmplBodyStart: PAnsiChar;
    FTmplBodyStop: PAnsiChar;
    FTmplStart: PAnsiChar;
    FTmplStop: PAnsiChar;
    FCompactOptions: TrsXMLCompactOptions;

    FEOL: RSLString;
    FIndentionDelta: integer;

    IsUnicode: boolean;
    CharSize: integer;

    procedure SetTemplate(const Value: TStrings);
    function IsTemplateStored: Boolean;

    function GetNextChar: word;
    function GetCurrChar: word;
    procedure SkipChar;
    function PreviewNextChars(const Count: integer): WideString;

    function EncodeStr(const Value: String): String;
    function DecodeStr(const Value: string): string;

{$IFDEF RSL_UNICODE}
    function EncodeStrW(const Value: WideString): WideString;
    function DecodeStrW(const Value: WideString): WideString;
{$ENDIF}

    //XML read procedures;
    function SkipSpaces: word;
    procedure SkipToStr(const Value: AnsiString);
    function SkipToChars(const LastChars: TrsXMLTokenEndChars): word;
    procedure DoEndTag;
    procedure DoStartTag;
    function GetToken(const LastChars: TrsXMLTokenEndChars): WideString;

    procedure StorageFill;

    function  GetValueAsString(KeyItem: PrsKeyItem): RSLString;
    procedure WriteFromString(const Key, Value: WideString; const Option: word);
  protected
    procedure LoadFromStream(Stream: TStream); override;
    procedure SaveToStream(Stream: TStream); override;
    procedure SaveSection;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property RootName: string read FRootName write FRootName;
  published
    property Template: TStrings read FTemplate write SetTemplate stored IsTemplateStored;
    property FileName;
    property FileDir;
    property InternalFileName;
    property InternalFileLoad;
    property Options;
    property XMLOptions: TrsXMLDataOptions read FXMLDataOptions write FXMLDataOptions default [];
{$IFDEF RSL_UNICODE}
    property Unicode;
{$ENDIF}
    property CompactOptions: TrsXMLCompactOptions read FCompactOptions write FCompactOptions default [];
    property OnLoadFromStream;
    property OnSaveToStream;
  end;

implementation

uses rsUtils;

const
  SBody = '%BODY%';
  SDefaultTemplate = '<?xml version="1.0" ?>' + CEOL +
                     '<!-- Generated by Storage library -->' + CEOL +
                     SBody + CEOL;
  CXMLSpaces: set of char = [#9,#10,#13,' '];

type
  TIntStorage = class(TrsStorage);


{ TrsXMLData }

constructor TrsXMLData.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FAttrNames := TStringList.Create;
  FAttrValues := TStringList.Create;
  FTemplate := TStringList.Create;
  FExtension := '.xml';
  FXMLDataOptions := [];

  FTemplate.Text := SDefaultTemplate;
  FRootName := 'DOCUMENT';
end;


function TrsXMLData.DecodeStr(const Value: string): string;
var
  sp,cp: PChar;
  ch: char;
  s: string;
  i: integer;
begin
  Result := Value;
  sp := PChar(Result);
  ch := #0; // off warning only
  While True do begin
    cp := StrPos(sp, '&');
    if cp=nil then Exit;

    sp := StrPos(cp, ';');
    if sp=nil then rsError(egXMLParser, SErrInEntity);

    if (cp+1)^='#' then begin
      SetString(s, cp+2, sp-cp-2);
      if (Length(s)>0) and (s[1]='x') then s[1] := '$';
      ch := Chr(StrToInt(s));
    end else
    if StrLIComp(cp+1, 'amp;',4)=0 then ch := '&'
     else
    if StrLIComp(cp+1, 'apos;',5)=0 then ch := ''''
     else
    if StrLIComp(cp+1, 'gt;',3)=0 then ch := '>'
     else
    if StrLIComp(cp+1, 'lt;',3)=0 then ch := '<'
     else
    if StrLIComp(cp+1, 'quot;',5)=0 then ch := '"'
     else
    if StrLIComp(cp+1, 'cr;',3)=0 then ch := Char(13)
     else
    if StrLIComp(cp+1, 'lf;',3)=0 then ch := Char(10)
     else
    if StrLIComp(cp+1, 'tab;',4)=0 then ch := Char(9)
     else rsError(egXMLParser, SErrUnknownEntity);

    Inc(sp);
    cp^ := ch;
    Inc(cp);
    i := cp-PChar(Result);
    Delete(Result, cp-PChar(Result)+1, sp-cp);
    sp := PChar(@Result[i+1]);
  end;
end;

{$IFDEF RSL_UNICODE}
function TrsXMLData.DecodeStrW(const Value: WideString): WideString;
var
  sp,cp: PWideChar;
  ch: WideChar;
  s: WideString;
  i: integer;
begin
  Result := Value;
  sp := PWideChar(Result);
  ch := #0; // off warning only
  While True do begin
    cp := StrPosW(sp, '&');
    if cp=nil then Exit;

    sp := StrPosW(cp, ';');
    if sp=nil then rsError(egXMLParser, SErrInEntity);

    if (cp+1)^='#' then begin
      SetString(s, cp+2, sp-cp-2);
      if (Length(s)>0) and (s[1]='x') then s[1] := '$';
      ch := WideChar(StrToInt(s));
    end else
    if RSLCompareStrLI(cp+1, 'amp;',4)=0 then ch := '&'
     else
    if RSLCompareStrLI(cp+1, 'apos;',5)=0 then ch := ''''
     else
    if RSLCompareStrLI(cp+1, 'gt;',3)=0 then ch := '>'
     else
    if RSLCompareStrLI(cp+1, 'lt;',3)=0 then ch := '<'
     else
    if RSLCompareStrLI(cp+1, 'cr;',3)=0 then ch := Char(13)
     else
    if RSLCompareStrLI(cp+1, 'lf;',3)=0 then ch := Char(10)
     else
    if RSLCompareStrLI(cp+1, 'tab;',4)=0 then ch := Char(9)
     else
    if RSLCompareStrLI(cp+1, 'quot;',5)=0 then ch := '"'
     else rsError(egXMLParser, SErrUnknownEntity);

    Inc(sp);
    cp^ := ch;
    Inc(cp);
    i := cp-PWideChar(Result);
    Delete(Result, cp-PWideChar(Result)+1, sp-cp);
    sp := PWideChar(@Result[i+1]);
  end;
end;
{$ENDIF}

destructor TrsXMLData.Destroy;
begin
  inherited Destroy; //really needed in first position, because Save in TrsStorageData.Destroy
  FTemplate.Free;
  FAttrValues.Free;
  FAttrNames.Free;
end;


procedure TrsXMLData.DoEndTag;
var
  s: WideString;
begin
  SkipChar; //skip "/"
  s := GetToken(['>',' ',#9,#10,#13]);

  if SkipSpaces=Ord('>')
    then GetNextChar
    else rsError(egXMLParser, SErrMissingEndTag);

  if s=FCurrentRootName then begin
    Storage.RootSection := '';
    FTmplBodyStop := PCur;
  end else begin
    {While s<>Storage.SectionName do
      if not Storage.ChangeUpRootSection then Break;
    if s=Storage.SectionName then} Storage.ChangeUpRootSection;
  end;
end;


procedure TrsXMLData.DoStartTag;
var
  PStart,PEnd,PSafe,PStartTag: PAnsiChar;
  s,s1: WideString;
  sA: AnsiString;
  flKey,flEmptyElement: boolean;
  i: integer;
  ch: char;
begin
  PStartTag := PCur;
  s := GetToken(['>','/',' ',#9,#10,#13]);

  FAttrNames.Clear;
  FAttrValues.Clear;
  if not (SkipSpaces in [Ord('>'),Ord('/')]) then begin //have an attributes
    While True do begin
      s1 := GetToken(['=',' ',#9,#10,#13]);
      if SkipSpaces<>Ord('=') then rsError(egXMLParser, SErrMissingEQ);
      FAttrNames.Add(s1);
      SkipChar;
      ch := Char(SkipSpaces);
      if not (ch in ['"','''']) then rsError(egXMLParser, SErrMissingQuote);
      SkipChar;
      s1 := GetToken([ch]);
      FAttrValues.Add(s1);
      SkipChar;
      if SkipSpaces in [Ord('/'),Ord('>')] then Break;
    end;
  end; //end of have an attributes, cursor at '/>' or '>'

  // begin find subelements
  PSafe := PCur;
  if GetCurrChar=Ord('/') then GetNextChar;
  if GetCurrChar<>Ord('>') then rsError(egXMLParser, SErrMissingEndTag);
  SkipChar;

  s1 := '';
  PStart := PCur;
  SkipToChars(['<',#0]);
  PEnd := PCur;
  if GetNextChar=Ord('/') then begin
    GetNextChar;
    s1 := GetToken(['>',' ',#9,#10,#13]);
  end;
  PCur := PSafe;
  // end find subelements

  flKey := ((GetCurrChar=Ord('/')) and (FAttrNames.Count=1) and (FAttrNames[0]='value')) or
           ((s1=s) and (FAttrNames.Count=0));

  //skip end of element
  flEmptyElement := GetCurrChar=Ord('/');
  if GetCurrChar=Ord('/') then GetNextChar;
  if GetCurrChar<>Ord('>') then rsError(egXMLParser, SErrMissingEndTag);
  SkipChar;


  if flKey then begin //add key
    if FAttrNames.Count=0 then begin //without attribute, with text
      {$IFDEF RSL_UNICODE}
      if IsUnicode then begin
        SetString(s1, nil, (PEnd-PStart) div CharSize);
        Move(PStart^, Pointer(s1)^, PEnd-PStart);
        WriteFromString(s, DecodeStrW(s1), 0);
      end else begin {$ENDIF}
        SetString(sA, PStart, PEnd-PStart);
        WriteFromString(s, DecodeStr(String(sA)), 0);
      {$IFDEF RSL_UNICODE}
      end;
      {$ENDIF}

      PCur := PEnd;
      SkipToChars(['>']);
      SkipChar;
    end else begin
      WriteFromString(s, DecodeStr(FAttrValues[0]), CXMLkoValueInAttribute);
    end;
  end else begin // add section
    if Length(FCurrentRootName)=0 then begin // root section
      FCurrentRootName := s;
      FTmplBodyStart := PStartTag-CharSize;
    end else begin // normal section
      if not (ssMerging in TintStorage(Storage).CurrentStates) then
        if Storage.SectionExist(s) then begin
          s := s + '_'+IntToStr(Storage.SectionCount);
        end;
      Storage.SectionAdd(s);
      Storage.ChangeDownRootSection(s);
      for i:=0 to FAttrNames.Count-1 do begin //add section attributes as Storage.key
        WriteFromString(FAttrNames[i], DecodeStr(FAttrValues[i]), CXMLkoAttribute);
      end;
      if flEmptyElement then Storage.ChangeUpRootSection; // if closed section
    end;
  end;
end;


function TrsXMLData.EncodeStr(const Value: String): String;
var
  sp,cp: PChar;
  s: string;
  i: integer;
begin
  sp := PChar(Value);
  cp := sp;
  Result := '';
  While True do begin
    While not (cp^ in ['&','<','>','"','''',#0]) do
      if (doEncodeTab in XMLOptions) and (cp^=#9)
        then Break
        else
      if (doEncodeCRLF in XMLOptions) and (cp^ in [#13,#10])
        then Break
        else Inc(cp);

    if cp^=#0 then begin
      if sp=PChar(Value) then begin
        Result := Value;
      end else begin
        i := Length(Result);
        SetLength(Result, i+(cp-sp));
        Move(sp^, Result[i+1], (cp-sp)*SizeOf(Char));
      end;
      Exit;
    end;

    case cp^ of
      '&': s := '&amp;';
      '<': s := '&lt;';
      '>': s := '&gt;';
      '"': s := '&quot;';
     '''': s := '&apos;';
     else
      if (doEncodeTab in XMLOptions) and (cp^=#9)
        then s := '&tab;'
        else
      if (doEncodeCRLF in XMLOptions) and (cp^=#13)
        then s := '&cr;'
        else
      if (doEncodeCRLF in XMLOptions) and (cp^=#10)
        then s := '&lf;'
        else s := '';
    end;

    i := Length(Result);
    SetLength(Result, i+(cp-sp)+Length(s));
    Move(sp^, Result[i+1], (cp-sp)*SizeOf(Char));
    Move(Pchar(s)^, Result[i+1+cp-sp], Length(s)*SizeOf(Char));
    Inc(cp);
    sp := cp;
  end;
end;

{$IFDEF RSL_UNICODE}
function TrsXMLData.EncodeStrW(const Value: WideString): WideString;
var
  sp,cp: PWideChar;
  s: WideString;
  i: integer;
begin
  sp := PWideChar(Value);
  cp := sp;
  Result := '';
  While True do begin
    While not (cp^ in [WideChar('&'), WideChar('<'),WideChar('>'),
                       WideChar('"'),WideChar(''''),WideChar(#0)]) do
      if (doEncodeTab in XMLOptions) and (cp^=WideChar(#9))
        then Break
        else
      if (doEncodeCRLF in XMLOptions) and (cp^ in [wideChar(#13),wideChar(#10)])
        then Break
        else Inc(cp);

    if cp^=#0 then begin
      if sp=PWideChar(Value) then begin
        Result := Value;
      end else begin
        i := Length(Result);
        SetLength(Result, i+(cp-sp));
        Move(sp^, Result[i+1], (cp-sp)*CharSize);
      end;
      Exit;
    end;

    case cp^ of
      '&': s := '&amp;';
      '<': s := '&lt;';
      '>': s := '&gt;';
      '"': s := '&quot;';
     '''': s := '&apos;';
     else
      if (doEncodeTab in XMLOptions) and (cp^=WideChar(#9))
        then s := '&tab;'
        else
      if (doEncodeCRLF in XMLOptions) and (cp^=WideChar(#13))
        then s := '&cr;'
        else
      if (doEncodeCRLF in XMLOptions) and (cp^=WideChar(#10))
        then s := '&lf;'
        else s := '';
    end;

    i := Length(Result);
    SetLength(Result, i+(cp-sp)+Length(s));
    Move(sp^, Result[i+1], (cp-sp)*CharSize);
    Move(PWideChar(s)^, Result[i+1+cp-sp], Length(s)*CharSize);
    Inc(cp);
    sp := cp;
  end;
end;
{$ENDIF}

function TrsXMLData.GetCurrChar: word;
begin
  if IsUnicode
    then Result := PWord(PCur)^
    else Result := PByte(PCur)^;
end;

function TrsXMLData.GetNextChar: word;
begin
  if IsUnicode then begin
    Inc(PCur,2);
    Result := PWord(PCur)^;
  end else begin
    Inc(PCur);
    Result := PByte(PCur)^;
  end;
end;

function TrsXMLData.GetToken(const LastChars: TrsXMLTokenEndChars): WideString;
var
  PStart: PAnsiChar;
  ch: word;
  s: AnsiString;
begin
  PStart := PCur;

  ch := GetCurrChar;
  While not (Char(ch) in LastChars) do
    if ch=0
      then rsError(egXMLParser, SErrXMLEOF)
      else ch := GetNextChar;

  if ch=0 then rsError(egXMLParser, SErrXMLEOF);
  if IsUnicode
    then begin
      SetString(Result, nil, (PCur-PStart) div CharSize);
      Move(PStart^, Pointer(Result)^, PCur-PStart);
    end else begin
      SetString(s, PStart, PCur-PStart);
      Result := String(s);
    end;
end;


function TrsXMLData.GetValueAsString(KeyItem: PrsKeyItem): RSLString;
begin
  Storage.KeyWrapper.PKeyItem := KeyItem;
  Result := Storage.KeyWrapper.AsString;
end;

function TrsXMLData.IsTemplateStored: Boolean;
begin
  Result := FTemplate.Text<>SDefaultTemplate;
end;


procedure TrsXMLData.LoadFromStream(Stream: TStream);
var
  i: integer;
  s,s1: String;
begin
  inherited;
  i := 0;
  if (Stream is TMemoryStream) then begin
    Stream.Seek(0,soFromEnd);
    Stream.Write(i,2);
    Stream.Position := 0;
    PCur := (Stream as TMemoryStream).Memory;
    i := Stream.Size-2;
  end else begin
    i := Stream.Size;
    SetString(s,nil,i+1);
    Stream.Read(Pointer(s)^, i);
    s[Length(s)] := #0;
    PCur := Pointer(s);
  end;
  PBufStart := PCur;
  ProgressItemCount := i;

  FTmplStart := PCur;
  FTmplStop := PCur + Stream.Size;
  FTmplBodyStart := nil;
  FTmplBodyStop := nil;

  FCurrentRootName := '';

  case PWord(PCur)^ of
   $FEFF: IsUnicode := True;
   $FFFE: begin // if UTF16LE
            SwapBytes(PWideChar(PCur));
            IsUnicode := True;
          end;
   else IsUnicode := False;
  end;

  CharSize := 1;
  if IsUnicode then begin
    Inc(CharSize);
    SkipChar; // skip $FEFF
  end;

  StorageFill;

  if Stream is TMemoryStream then begin
    Stream.Size := Stream.Size-2; // delete #0 bytes
  end;

  if doGetTemplateOnLoad in XMLOptions then begin
    SetString(s, FTmplStart, FTmplBodyStart - FTmplStart);
    SetString(s1, FTmplBodyStop, FTmplStop - FTmplBodyStop);
    FTemplate.Text := s + SBody + s1;
  end;
end;


function TrsXMLData.PreviewNextChars(const Count: integer): WideString;
var
  s: AnsiString;
begin
  if IsUnicode
    then begin
      SetString(Result, nil, Count);
      Move(PCur^, Pointer(Result)^, Count*CharSize);
    end else begin
      SetString(s, PCur, Count);
      Result := String(s);
    end;
end;

procedure TrsXMLData.SaveSection;
var
  i,iAttrCnt,RangeBegin, RangeEnd, RngBegin, RngEnd: integer;
  pKI: PrsKeyItem;
  pSI: PrsSectionItem;
  s: RSLString;
  fl: boolean;
  {$IFDEF RSL_UNICODE}
  k: integer;
  {$ENDIF}
begin

{$IFDEF RSL_UNICODE}
  if IsUnicode then begin
    for k:=0 to FCurrentIndention-1 do BufferWriteCharW(' ');
    BufferWriteCharW('<');
    BufferWriteStrW(FCurrentSectionName);
  end else {$ENDIF}
    BufferWriteFmtA(FCurrentIndention+Length(FCurrentSectionName)+1,
                    '%*s<%s', [FCurrentIndention, '', AnsiString(FCurrentSectionName)]);

  iAttrCnt := 0;
  if TIntStorage(Storage).GetKeyRange(RangeBegin, RangeEnd) then begin
    for i:=RangeBegin to RangeEnd-1 do begin
      pKI := TIntStorage(Storage).GetKeyItem(i);
      if (pKI^.Value.Options and CXMLkoAttribute) > 0 then begin
        s := GetValueAsString(pKI);
        if pKI^.Value.kvType = kvtString then begin
          {$IFDEF RSL_UNICODE}
          if IsUnicode
           then s := EncodeStrW(s)
           else {$ENDIF} s := EncodeStr(s);
        end;
        {$IFDEF RSL_UNICODE}
        if IsUnicode then begin
          BufferWriteStrW(pKI^.Name);
          BufferWriteCharsW(['=', '"']);
          BufferWriteStrW(s);
          BufferWriteCharW('"');
        end else {$ENDIF}
          BufferWriteFmtA(Length(pKI^.Name)+Length(s)+4, ' %s="%s"',[AnsiString(pKI^.Name), AnsiString(s)]);
        Inc(iAttrCnt);

        Inc(ProgressItemCurrent);
        DoProgress;
      end;
    end;
    iAttrCnt := (RangeEnd-RangeBegin)-iAttrCnt;
  end;

  if (iAttrCnt=0) and (not TIntStorage(Storage).GetSectionChildRange(RangeBegin, RangeEnd))
   then begin
     {$IFDEF RSL_UNICODE}
     if IsUnicode
      then BufferWriteStrW('/>'+FEOL)
      else {$ENDIF} BufferWriteStrA('/>'+AnsiString(FEOL));
     Exit;
   end else begin
     {$IFDEF RSL_UNICODE}
     if IsUnicode
      then BufferWriteStrW('>'+FEOL)
      else {$ENDIF} BufferWriteStrA('>'+AnsiString(FEOL));
   end;

  Inc(FCurrentIndention, FIndentionDelta);

  if TIntStorage(Storage).GetKeyRange(RangeBegin, RangeEnd) then
    for i:=RangeBegin to RangeEnd-1 do begin
      pKI := TIntStorage(Storage).GetKeyItem(i);
      if (pKI^.Value.Options and CXMLkoAttribute) = 0 then begin
        fl := ((pKI^.Value.Options and CXMLkoValueInAttribute)>0) or (doKeyValueInAttribute in XMLOptions);
        if fl and ((pKI^.Value.kvType=kvtBuffer) or ((pKI^.Value.Options and CXMLkoValueInData)>0))
          then fl := False;
        if fl then begin
          s := GetValueAsString(pKI);
          if pKI^.Value.kvType = kvtString then s := EncodeStr(s);
          {$IFDEF RSL_UNICODE}
          if IsUnicode then begin
            for k:=0 to FCurrentIndention-1 do BufferWriteCharW(' ');
            BufferWriteCharW('<');
            BufferWriteStrW(pKI^.Name);
            BufferWriteStrW(' value="');
            BufferWriteStrW(s);
            BufferWriteStrW('"/>'+FEOL);
          end else {$ENDIF}
            BufferWriteFmtA(FCurrentIndention+Length(pKI^.Name)+Length(s)+12+Length(FEOL),
                                  '%*s<%s value="%s"/>'+AnsiString(FEOL),
                                  [FCurrentIndention, '', AnsiString(pKI^.Name), AnsiString(s)]);
        end else begin
          {$IFDEF RSL_UNICODE}
          if IsUnicode then begin
            for k:=0 to FCurrentIndention-1 do BufferWriteCharW(' ');
            BufferWriteCharW('<');
            BufferWriteStrW(pKI^.Name);
            BufferWriteCharW('>');
          end else {$ENDIF}
            BufferWriteFmtA(FCurrentIndention+Length(pKI^.Name)+2, '%*s<%s>', [FCurrentIndention, '', AnsiString(pKI^.Name)]);

          if pKI^.Value.kvType=kvtBuffer then begin
            RSHexStrStartOffset := FCurrentIndention+Length(pKI^.Name)+2;
            RSHexStrLineSeparator := AnsiString(FEOL);
            RSHexStrCompact := coHexStr in CompactOptions; //17.12.2001
          end;
            s := GetValueAsString(pKI);
            if pKI^.Value.kvType = kvtString then s := EncodeStr(s);
            {$IFDEF RSL_UNICODE}
            if IsUnicode then begin
              BufferWriteStrW(s);
              BufferWriteStrW('</'+pKI^.Name+'>'+FEOL);
            end else begin
            {$ENDIF}
              BufferWriteStrA(AnsiString(s));
              BufferWriteFmtA(Length(pKI^.Name)+3+Length(FEOL), '</%s>'+AnsiString(FEOL), [AnsiString(pKI^.Name)]);
            {$IFDEF RSL_UNICODE}
            end;
            {$ENDIF}
        end;
        Inc(ProgressItemCurrent);
        DoProgress;
      end;
    end;

  s := FCurrentSectionName;

  if TIntStorage(Storage).GetSectionChildRange(RangeBegin, RangeEnd) then
    for i:=RangeBegin to RangeEnd-1 do begin
      pSI := TIntStorage(Storage).GetSectionItem(i);
      if Storage.ChangeDownRootSection(pSI^.Name) then begin
        if TIntStorage(Storage).GetKeyRange(RngBegin, RngEnd) or
           TIntStorage(Storage).GetSectionChildRange(RngBegin, RngEnd) or
           (soSaveEmptySection in Storage.Options)
          then begin
            FCurrentSectionName := pSI^.Name;
            SaveSection;
          end;
        Storage.ChangeUpRootSection;
      end;
    end;

  Dec(FCurrentIndention, FIndentionDelta);
  {$IFDEF RSL_UNICODE}
  if IsUnicode then begin
    for k:=0 to FCurrentIndention-1 do BufferWriteCharW(' ');
    BufferWriteStrW('</');
    BufferWriteStrW(s);
    BufferWriteCharW('>');
    BufferWriteStrW(FEOL);
  end else {$ENDIF}
    BufferWriteFmtA(FCurrentIndention+Length(s)+3+Length(FEOL), '%*s</%s>'+AnsiString(FEOL), [FCurrentIndention, '', AnsiString(s)]);
end;


procedure TrsXMLData.SaveToStream(Stream: TStream);
var
  s, sOut: string;
  i: integer;
begin
  inherited;
  FCurrentIndention := 0;
  FCurrentSectionName := FRootName;
  BufferClear;

  if coIndent in CompactOptions
    then FIndentionDelta := 0
    else FIndentionDelta := 2;

  if coEOL in CompactOptions
    then FEOL := ''
    else FEOL := CEOL;

{$IFDEF RSL_UNICODE}
  IsUnicode := Unicode;
{$ELSE}
  IsUnicode := False;
{$ENDIF}

  CharSize := 1;
  {$IFDEF RSL_UNICODE}
  if IsUnicode then begin
    BufferWriteCharW(#$FEFF);
    Inc(CharSize);
  end;
  {$ENDIF}

  s := FTemplate.Text;
  i := pos(SBody, s);
  if i>0 then sOut := Copy(s, 1, i-1)
    else sOut := s;
  {$IFDEF RSL_UNICODE}
  if IsUnicode
    then BufferWriteStrW(sOut)
    else {$ENDIF}BufferWriteStrA(AnsiString(sOut));

  ProgressItemCount := TIntStorage(Storage).KeyCountAll;
  DoProgress;

  SaveSection;

  Dec(BufferStart, Length(FEOL)*CharSize); //Delete last EOL

  if i>0 then begin //has a postfix on template
    Inc(i, Length(SBody));
    if i<=Length(s) then begin
      sOut := Copy(s, i, Length(s)-i+1);
      {$IFDEF RSL_UNICODE}
      if IsUnicode
        then BufferWriteStrW(sOut)
        else {$ENDIF} BufferWriteStrA(AnsiString(sOut));
    end;
  end;

  BufferFlush;
end;


procedure TrsXMLData.SetTemplate(const Value: TStrings);
begin
  FTemplate.Assign(Value);
end;


procedure TrsXMLData.SkipChar;
begin
  Inc(PCur, CharSize);
end;

function TrsXMLData.SkipSpaces: word;
begin
  Result := GetCurrChar;
  While Char(Result) in CXMLSpaces do Result := GetNextChar;
  if Result=0 then rsError(egXMLParser, SErrXMLEOF);
end;


function TrsXMLData.SkipToChars(const LastChars: TrsXMLTokenEndChars): word;
begin
  Result := GetCurrChar;
  While not (Char(Result) in LastChars) do
    if GetCurrChar=0
      then rsError(egXMLParser, SErrXMLEOF)
      else Result := GetNextChar;

  if (Result=0) and (not (Char(Result) in LastChars))
    then rsError(egXMLParser, SErrXMLEOF);
end;

procedure TrsXMLData.SkipToStr(const Value: AnsiString);
var
  TP: PAnsiChar;
  sW: WideString;
begin
  if IsUnicode then begin
    sW := WideString(Value);
    TP := PansiChar(StrPosW(PWideChar(PCur), @sW[1]));
  end else begin
    TP := AnsiStrPos(PCur, PAnsiChar(Value));
  end;

  if TP<>nil
    then PCur := TP + Length(Value)*CharSize
    else rsError(egXMLParser, Format(SErrXMLEOF,[Value]));
end;

procedure TrsXMLData.StorageFill;
var
  i: integer;
  ch: word;
  sW: RSLString;
begin
  DoProgress;
  While True do begin
    ch := GetCurrChar;
    While Char(ch) in CXMLSpaces do ch := GetNextChar;
    if ch=0 then Break;
    if ch<>Ord('<') then rsError(egXMLParser, SErrMissingBeginTag);

    ch := GetNextChar;
    if ch=Ord('/') then begin DoEndTag; Continue; end;

    if ch = Ord('?') then begin  SkipToStr('?>'); Continue; end;
    sW := PreviewNextChars(3);
    if RSLCompareStrLI('!--', PRSLChar(sW), 3)=0 then begin SkipToStr('-->'); Continue; end;
    sW := PreviewNextChars(8);
    if RSLCompareStrLI('![CDATA[', PRSLChar(sW), 8)=0 then begin SkipToStr(']]>'); Continue; end;
    if RSLCompareStrLI('!DOCTYPE', PRSLChar(sW), 8)=0 then begin
      i := 0;
      While True do begin
        ch := SkipToChars(['<','>']);
        if ch=Ord('<') then begin
          Inc(i);
        end else
        if ch=Ord('>') then begin
          if i>0 then Dec(i) else Break;
        end;
        SkipChar;
      end;
      Continue;
    end;
    if ch = Ord('!') then begin  SkipToStr('>'); Continue; end; //skip ENTITY,NOTATION and ???

    DoStartTag;
    ProgressItemCurrent := PCur-PBufStart;
    DoProgress;
  end;
  ProgressItemCurrent := PCur-PBufStart;
  DoProgress;
end;



procedure TrsXMLData.WriteFromString(const Key, Value: WideString; const Option: word);
var
  i,idx,x,y: integer;
  sA: AnsiString;
begin
  idx := TintStorage(Storage).KeyFindAddItem(Key, True);
  if idx>=0 then begin
    Storage.KeyWrapper.KeyOptions := Storage.KeyWrapper.KeyOptions or Option;
    if Length(Value)=0 then Exit;

      case IsDigitValueW(PWideChar(Value), Length(Value)) of
        1: begin
             i := StrToInt(Value);
             if Length(IntToStr(i))<>Length(Value)
              then begin
                if (Length(Value)=2) and IsHexStrW(PWideChar(Value), Length(Value))
                  then begin
                    sA := HexStrWToBinBuf(PWideChar(Value), Length(Value));
                    Storage.KeyWrapper.SetAsBuffer(Pointer(sA)^, Length(sA));
                  end else Storage.KeyWrapper.AsString := Value;
              end else Storage.KeyWrapper.AsInteger := i;
             Exit;
           end;
        2: begin
             Storage.KeyWrapper.AsFloat := StrToFloat(Value);
             Exit;
           end;
        {$IFDEF RSL_INT64}
        3: begin
             Storage.KeyWrapper.AsInt64 := StrToInt64(Value);
             Exit;
           end;
        {$ENDIF}
      end;

      i := RSLCompareText(RSBooleanIdentsTrue, Value);
      if i=0 then begin
        Storage.KeyWrapper.AsBoolean := True;
        Exit;
      end;

      i := RSLCompareText(RSBooleanIdentsFalse, Value);
      if i=0 then begin
        Storage.KeyWrapper.AsBoolean := False;
        Exit;
      end;

      //Error намудрено с Length(s)=>Length(Value), наверно не работает !!!!
      if (Value[1]='(') and (Value[Length(Value)]=')') then begin
        i := Pos(',', Value);
        if i>0 then begin
          if IsDigitValueW(PWideChar(Value), i-1)=1 then begin
            x := StrToInt(Copy(Value, 1, i-1));
            if IsDigitValueW(PWideChar(@Value[i+1]), Length(Value)-i)=1 then begin
              y := StrToInt(Copy(Value, i+1, length(Value)-i));
              Storage.KeyWrapper.AsPoint := Point(x,y);
              Exit;
            end;
          end;
        end;
      end;

      if Char(Value[1]) in ['0'..'9','A'..'F','a'..'f'] then begin
        if IsHexStrW(PWideChar(Value), Length(Value)) then begin
          sA := HexStrWToBinBuf(PWideChar(Value), Length(Value));
          if Length(sA)>0 then begin
            Storage.KeyWrapper.SetAsBuffer(Pointer(sA)^, Length(sA));
            Exit;
          end;
        end;
      end;

      Storage.KeyWrapper.AsString := Value;
  end;
end;

end.
